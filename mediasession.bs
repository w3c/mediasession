<pre class="metadata">
Title: Media Session Standard
Group: WHATWG
H1: Media Session
Shortname: mediasession
Status: LS
No Editor: true
Logo: https://resources.whatwg.org/logo-mediasession.svg
Abstract: This specification enables web developers to obtain different levels
Abstract: of platform media focus, customize available platform media controls,
Abstract: and access platform media keys such as hardware keys found on
Abstract: keyboards, headsets, remote controls, and software keys found in
Abstract: notification areas and on lock screens of mobile devices.
!Participate: <a href="https://github.com/whatwg/mediasession/issues/new">File an issue</a> (<a href="https://github.com/whatwg/mediasession/issues?state=open">open issues</a>)
!Participate: <a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
!Version History: <a href="https://github.com/whatwg/mediasession/commits">https://github.com/whatwg/mediasession/commits</a>
Ignored Vars: context, media
Boilerplate: omit conformance, omit feedback-header
</pre>

<script src=https://resources.whatwg.org/file-issue.js async></script>

<style>
  /* https://github.com/tabatkins/bikeshed/issues/485 */
  .example .self-link { display: none; }
</style>

<pre class="anchors">
urlPrefix: https://html.spec.whatwg.org/multipage/; spec: HTML
    type: interface
        urlPrefix: dom.html
            text: Document
        urlPrefix: embedded-content.html
            text: HTMLMediaElement
        urlPrefix: webappapis.html
            text: EventHandler
    type: element
        urlPrefix: embedded-content.html
            text: video
            text: audio
    type: dfn
        urlPrefix: infrastructure.html
            text: case-sensitive; url: #case-sensitivity-and-string-comparison
            text: reflect
            text: limited to only known values
            text: remove an element from a document; url: #remove-an-element-from-a-document
            text: in parallel
        urlPrefix: embedded-content.html
            text: media element
            text: media element load algorithm
            text: potentially playing
            text: ended playback
            text: internal pause steps
        urlPrefix: infrastructure.html
            text: enumerated attribute
        urlPrefix: browsers.html
            text: browsing context
            text: top-level browsing context; url: #top-level-browsing-context
        urlPrefix: webappapis.html
            text: API base URL
            text: entry settings object
            text: event handlers
            text: event handler event type
            text: event handler content attributes
            text: queue a task
            text: fire a simple event
            text: task
            text: task source
            text: DOM manipulation task source
    type: method
        urlPrefix: embedded-content.html
            text: play(); for: HTMLMediaElement; url: #dom-media-play
            text: pause(); for: HTMLMediaElement; url: #dom-media-pause
    type: attribute
        urlPrefix: embedded-content.html
            text: controls; url: #attr-media-controls
            text: paused; for: HTMLMediaElement; url: #dom-media-paused
            text: readyState; for: HTMLMediaElement; url: #dom-media-readystate
            text: HAVE_FUTURE_DATA; for: HTMLMediaElement; url: #dom-media-have_future_data
            text: HAVE_ENOUGH_DATA; for: HTMLMediaElement; url: #dom-media-have_enough_data
            text: networkState; for: HTMLMediaElement; url: #dom-media-networkstate
            text: NETWORK_LOADING; for: HTMLMediaElement; url: #dom-media-network_loading
            text: NETWORK_IDLE; for: HTMLMediaElement; url: #dom-media-network_idle
    type: event
        urlPrefix: embedded-content.html
            text: pause; url: #event-media-pause
            text: play; url: #event-media-play
urlPrefix: https://url.spec.whatwg.org/;
    type: dfn; urlPrefix: #concept-
        text: url parser
        text: event listener
urlPrefix: https://fetch.spec.whatwg.org/; spec: FETCH
    type: dfn; urlPrefix: #concept-
        text: fetch
        text: request
        text: context; url: request-context
        text: context frame type; url: request-context-frame-type
        text: internal response
        text: origin; url: request-origin
        text: referrer; url: request-referrer
        text: response
        text: response type
        text: url; url: request-url
    type: dfn;
        text: force Origin header flag
urlPrefix: https://webaudio.github.io/web-audio-api/; spec: WEBAUDIO
    type: interface
        text: AudioContext
    type: attribute; urlPrefix: #widl-
        text: state; url: AudioContext-state
    type: enum; urlPrefix: #idl-def-AudioContextState.
        text: suspended
        text: running
        text: closed
    type: method; urlPrefix: #widl-
        text: suspend(); url: AudioContext-suspend-Promise-void
        text: resume(); url: AudioContext-resume-Promise-void
urlPrefix: https://dom.spec.whatwg.org/; spec: WHATWG-DOM
    type: interface; urlPrefix: #interface-
        text: EventTarget
        text: Event
urlPrefix: http://www.w3.org/TR/DOM-Level-3-Events-key/; spec: dom-level-3-events-key
    type: attribute; urlPrefix: #key-
        text: MediaPlayPause; url: MediaPlayPause
        text: MediaTrackPrevious; url: MediaTrackPrevious
        text: MediaTrackNext; url: MediaTrackNext
urlPrefix: http://www.w3.org/TR/page-visibility/; spec: PAGE-VISIBILITY
    type: attribute
        text: visibilityState; url: #dom-document-visibilitystate
    type: event
        text: visibilitychange; url: #sec-visibilitychange-event
    type: enum; urlPrefix: #pv-page-
        text: visible
        text: hidden
urlPrefix: https://heycam.github.io/webidl/
    type: exception
        text: InvalidStateError
        text: NotAllowedError
</pre>

<h2 id="introduction">Introduction</h2>

<em>This section is non-normative.</em>

Media is used extensively today on the web to play a variety of different types
of content. It is often used to play music, podcasts and radio content. At other
times web media is used to provide background music, sound effects, notification
sounds and to render WebRTC media stream content.

When playing media on the web, developers are currently forced to adopt a single
default platform modality for playing all media content. On the other hand,
native applications can access much richer media integration options with an
underlying platform. On mobile devices, native application developers can
request many different forms of media integration with the platform to obtain
access to headphone buttons, lock screens and notification areas as needed. On
desktop devices, native applications have access to keyboard media key events.
Native application developers can specify the conditions in which media content
should pause or duck on audio interruptions (i.e. pause or lower the volume for
the duration of an interruption), continue playing out when application focus is
lost or the device screen is switched off and interface with internal and
external remote controllers.

This specification provides these platform media integration features for web
media. By allowing web developers to express the intended usage of their media
content, user agents can supply the most suitable platform-level interactions
for that content and enforce logical interoperation behavior on the current
platform between any number of different sources of media.

This specification describes the mechanism that allows web developers to specify
the most appropriate kind for their media content and for user agents to then
use these supplied hints to enforce how different sources of web media should
interact with each other, other native media content and the underlying
platform.

<h2 id="conformance">Conformance</h2>

All diagrams, examples, and notes in this specification are non-normative, as
are all sections explicitly marked non-normative. Everything else in this
specification is normative.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119. For readability, these
words do not appear in all uppercase letters in this specification. [[!RFC2119]]

Requirements phrased in the imperative as part of algorithms (such as "strip any
leading space characters" or "return false and terminate these steps") are to be
interpreted with the meaning of the key word ("must", "should", "may", etc) used
in introducing the algorithm.

Conformance requirements phrased as algorithms or specific steps may be
implemented in any manner, so long as the end result is equivalent. (In
particular, the algorithms defined in this specification are intended to be easy
to follow, and not intended to be performant.)

User agents may impose implementation-specific limits on otherwise unconstrained
inputs, e.g. to prevent denial of service attacks, to guard against running out
of memory, or to work around platform-specific limitations.

When a method or an attribute is said to call another method or attribute, the
user agent must invoke its internal API for that attribute or method so that
e.g. the author can't change the behavior by overriding attributes or methods
with custom properties or functions in JavaScript.

Unless otherwise stated, string comparisons are done in a <a>case-sensitive</a>
manner.

<h2 id="dependencies">Dependencies</h2>

The IDL fragments in this specification must be interpreted as required for
conforming IDL fragments, as described in the Web IDL specification. [[!WEBIDL]]

<h2 id="the-mediasession-interface">The {{MediaSession}} interface</h2>

<pre class="idl">
[Constructor(optional MediaSessionKind kind = "content")]
interface MediaSession {
  readonly attribute MediaSessionKind kind;
  attribute MediaMetadata? metadata;

  Promise&lt;void> activate();
  Promise&lt;void> deactivate();
};

enum MediaSessionKind {
  "content",
  "transient",
  "transient-solo",
  "ambient"
};
</pre>

{{MediaSession}} objects are simply known as <dfn lt="media session">media
sessions</dfn>.

A <a>media session</a> has <dfn lt="media session metadata">metadata</dfn>,
which is either a {{MediaMetadata}} object or null.

<dl class=domintro>
  <dt>
    <code><var>session</var> = new <a constructor
    lt="MediaSession()">MediaSession</a>([<var>kind</var>])</code>
  </dt>
  <dd>
    Returns a new {{MediaSession}} object.
  </dd>
  <dt>
    <code><var>session</var> . {{MediaSession/kind}}</code>
  </dt>
  <dd>
    Returns the <a>media session</a>'s <a>kind</a>.
  </dd>
  <dt>
    <code><var>session</var> . {{MediaSession/metadata}}</code>
  </dt>
  <dd>
    Returns the <a>media session</a>'s {{MediaMetadata}} object, if any, or null
    otherwise.

    Can be set, to a {{MediaMetadata}} object or null.
  </dd>
  <dt>
    <code><var>session</var> . {{MediaSession/activate()}}</code>
  </dt>
  <dd>
    Requests platform-level media focus and sets the <a>media session</a>'s
    <a>state</a> to <code><a lt="active media session state">active</a></code>.

    Throws a {{NotAllowedError}} exception if the request was denied by the user
    agent or the platform.
  </dd>
  <dt>
    <code><var>session</var> . {{MediaSession/deactivate()}}</code>
  </dt>
  <dd>
    Releases platform-level media focus and sets the <a>media session</a>'s
    <a>state</a> to <code><a lt="idle media session state">idle</a></code>.
  </dd>
</dl>

The <dfn constructor
for="MediaSession"><code>MediaSession(<var>kind</var>)</code></dfn>
constructor, when invoked, must return a new <a>media session</a> whose
<a>kind</a> is <var>kind</var>, and <a>state</a> is <code><a lt="idle media
session state">idle</a></code>.

The <dfn attribute for="MediaSession"><code>kind</code></dfn>
attribute must return the <a>media session</a>'s <a>kind</a>.

The <dfn attribute for="MediaSession"><code>metadata</code></dfn> attribute, on
getting, must return the <a>media session</a>'s <a lt="media session
metadata">metadata</a>. On setting, the <a>media session</a>'s <a lt="media
session metadata">metadata</a> must be set to the new value.

The <dfn method for="MediaSession"><code>activate()</code></dfn> method, when
invoked, must run these steps:

<ol>
  <li>
    Let <var>media session</var> be the <a>context object</a>.
  </li>
  <li>
    Let <var>promise</var> be a new promise.
  </li>
  <li>
    Return <var>promise</var>, and run the remaining steps <a>in parallel</a>.
  </li>
  <li>
    <a>Activate</a> <var>media session</var>.
  </li>
  <li>
    If <a>activate</a> failed, reject <var>promise</var> with a
    {{NotAllowedError}} exception.
  </li>
  <li>
    Otherwise, fulfill <var>promise</var> with undefined.
  </li>
</ol>

Note: {{activate()}} can fail if there is an ongoing high-priority activity,
e.g. a phone call.

The <dfn method for="MediaSession"><code>deactivate()</code></dfn> method, when
invoked, must run these steps:

<ol>
  <li>
    Let <var>media session</var> be the <a>context object</a>.
  </li>
  <li>
    Let <var>promise</var> be a new promise.
  </li>
  <li>
    Return <var>promise</var>, and run the remaining steps <a>in parallel</a>.
  </li>
  <li>
    <a>Deactivate</a> <var>media session</var>.
  </li>
  <li>
    Fulfill <var>promise</var> with undefined.
  </li>
</ol>

Note: Unlike {{activate()}}, {{deactivate()}} cannot fail.

<h3 id="media-session-states">States</h3>

A <a>media session</a> has a <dfn for="MediaSession">state</dfn> that describes
its current status with respect to any platform-level interactions and
interactions with other <a>media sessions</a>. The possible values are as
follows:

<dl>
  <dt>
    <dfn lt="idle media session state"><code>idle</code></dfn>
  </dt>
  <dd>
    The <a>media session</a> does not have any platform-level media focus nor is
    it in a suspended state.
  </dd>
  <dt>
    <dfn lt="active media session state"><code>active</code></dfn>
  </dt>
  <dd>
    The <a>media session</a> currently has platform-level media focus.
  </dd>
  <dt>
    <dfn lt="interrupted media session state"><code>interrupted</code></dfn>
  </dt>
  <dd>
    The <a>media session</a> is currently suspended from having platform-level
    media focus and its <a>audio-producing participants</a> are either <a
    lt="pause">paused</a> or
    <a lt="duck">ducked</a> based on the <a>media session</a>'s <a>kind</a>.
  </dd>
</dl>

<h3 id="media-session-kinds">Kinds</h3>

A <a>media session</a> has a <dfn for="MediaSession">kind</dfn> which is one of
"<code><dfn>content</dfn></code>", "<code><dfn>transient</dfn></code>",
"<code><dfn>transient-solo</dfn></code>" and "<code><dfn>ambient</dfn></code>".

<div class="note">
  The following table lists the available <a>kinds</a>, their associated
  behavior, and examples of when they are appropriate to use.

  <table>
    <tr>
      <th>Kind</th>
      <th>Behavior</th>
      <th>Examples</th>
    </tr>
    <tr>
      <td>
        "<code><a>content</a></code>"
      </td>
      <td>
        <ul>
          <li>
            <a>Indefinitely pauses</a> all other <a lt="audio-producing
            participants">active</a> "<code><a>content</a></code>" content when
            <a href="#activating-a-media-session">playback begins</a>.
          </li>
          <li>
            Displays lock-screen and notification area user interfaces when
            <a href="#activating-a-media-session">playback begins</a>.
          </li>
          <li>
            Reacts to changes in both hardware and software-based media key
            buttons when <a href="#activating-a-media-session">playback
            begins</a>.
          </li>
          <li>
            <a>Ducks</a> itself when "<code><a>transient</a></code>" content <a
            href="#interrupting-a-media-session">starts interrupting</a>.
            <a>Unducks</a>
            itself when "<code><a>transient</a></code>" content is <a>paused</a>
            or <a href="#deactivating-a-media-session">ends playback</a>.
          </li>
          <li>
            <a>Pauses</a> itself when "<code><a>transient-solo</a></code>"
            content <a href="#interrupting-a-media-session">starts
            interrupting</a>.
            <a>Unpauses</a> itself when "<code><a>transient-solo</a></code>"
            content is
            <a>paused</a> or <a href="#deactivating-a-media-session">ends
            playback</a>.
          </li>
          <li>
            Continues playing normally when "<code><a>ambient</a></code>"
            content <a href="#interrupting-a-media-session">starts
            interrupting</a>.
          </li>
        </ul>
      </td>
      <td>
        Music, podcasts, radio streams.
      </td>
    </tr>
    <tr>
      <td>
        "<code><a>transient</a></code>"
      </td>
      <td>
        <ul>
          <li>
            <a>Ducks</a> all other <a lt="audio-producing
            participants">active</a>
            "<code><a>content</a></code>" content when
            <a href="#activating-a-media-session">playback begins</a>.
            <a>Unducks</a> all other <a lt="interrupted media session
            state">interrupted</a> "<code><a>content</a></code>" content when
            <a>paused</a> or <a href="#deactivating-a-media-session">playback
            ends</a>.
          </li>
          <li>
            Does not display lock-screen and notification area user interfaces
            when <a href="#activating-a-media-session">playback begins</a>.
          </li>
          <li>
            Does not react to changes in both hardware and software-based media
            key buttons when <a href="#activating-a-media-session">playback
            begins</a>.
          </li>
          <li>
            <a>Pauses</a> itself when "<code><a>transient-solo</a></code>"
            content <a href="#interrupting-a-media-session">starts
            interrupting</a>.
            <a>Unpauses</a> itself when "<code><a>transient-solo</a></code>"
            content is
            <a>paused</a> or <a href="#deactivating-a-media-session">ends
            playback</a>.
          </li>
          <li>
            Continues playing normally when other
            "<code><a>transient</a></code>" or "<code><a>ambient</a></code>"
            content <a href="#interrupting-a-media-session">starts
            interrupting</a>.
          </li>
        </ul>
      </td>
      <td>
        Notification sounds. Spoken driving directions where playback of music
        in the background is acceptable.
      </td>
    </tr>
    <tr>
      <td>
        "<code><a>transient-solo</a></code>"
      </td>
      <td>
        <ul>
          <li>
            <a>Pauses</a> all other <a lt="audio-producing
            participants">active</a>
            "<code><a>content</a></code>", "<code><a>transient</a></code>" and
            "<code><a>transient-solo</a></code>" content when <a
            href="#activating-a-media-session">playback begins</a>.
            <a>Unpauses</a> all <a lt="interrupted media session
            state">interrupted</a>
            "<code><a>content</a></code>", "<code><a>transient</a></code>" and
            "<code><a>transient-solo</a></code>" content when <a>paused</a> or
            <a href="#deactivating-a-media-session">playback ends</a>.
          </li>
          <li>
            Does not display lock-screen and notification area user interfaces
            when <a href="#activating-a-media-session">playback begins</a>.
          </li>
          <li>
            Does not react to changes in both hardware and software-based media
            key buttons when <a href="#activating-a-media-session">playback
            begins</a>.
          </li>
          <li>
            <a>Pauses</a> itself when other "<code><a>transient-solo</a></code>"
            content <a href="#interrupting-a-media-session">starts
            interrupting</a>.
            <a>Unpauses</a>
            itself when other "<code><a>transient-solo</a></code>" content is
            <a>paused</a> or <a href="#deactivating-a-media-session">ends
            playback</a>.
          </li>
          <li>
            Continues playing normally when "<code><a>ambient</a></code>"
            content <a href="#interrupting-a-media-session">starts
            interrupting</a>.
          </li>
        </ul>
      </td>
      <td>
        Playback of driving directions. Other spoken notifications.
      </td>
    </tr>
    <tr>
      <td>
        "<code><a>ambient</a></code>"
      </td>
      <td>
        <ul>
          <li>
            Does not interact with any other "<code><a>content</a></code>",
            "<code><a>transient</a></code>",
            "<code><a>transient-solo</a></code>" or
            "<code><a>ambient</a></code>" content during playback.
          </li>
          <li>
            Does not display lock-screen and notification area user interfaces
            when <a href="#activating-a-media-session">playback begins</a>.
          </li>
          <li>
            Does not react to changes in both hardware and software-based media
            key buttons when <a href="#activating-a-media-session">playback
            begins</a>.
          </li>
          <li>
            <a>Pauses</a> itself when its <a>top-level browsing context</a> is
            not visible (i.e. the page is placed in the background or the user
            agent is minimized or the screen is switched off). <a>Unpauses</a>
            itself when its
            <a>top-level browsing context</a> is at least partially visible on
            at least one screen again (i.e. the user agent is in the foreground
            and the page is focused again).
          </li>
        </ul>
      </td>
      <td>
        UI sounds. In-game sound effects and background music.
      </td>
    </tr>
  </table>
</div>

<h3 id="media-session-participants">Participants</h3>

An <dfn>audio-producing object</dfn> is any object or element that is capable of
emitting sound within the user agent and is therefore also potentially capable
of interacting with the media focus system available in different underlying
platforms.

An <a>audio-producing object</a> may have a <dfn>current media session</dfn>,
which is a <a>media session</a>.

A <a>media session</a> may have one or more <a>audio-producing objects</a>
attached to it; called its <dfn>audio-producing participants</dfn>. A <a>media
session</a> must keep a list of its <a>audio-producing participants</a> that
consists of zero of more <a>audio-producing objects</a>.

A <a>media session</a> has a <dfn>resume list</dfn> that is used internally to
restore <a>audio-producing participants</a> at the end of an interruption that
were playing, or were otherwise running, when that interruption started. The
<a>resume list</a> may consist of zero or more <a>audio-producing objects</a>
that must also be present in the <a>media session</a>'s list of
<a>audio-producing participants</a>. When a new <a>media session</a> is created
its <a>resume list</a> must be empty.

When the user agent is to <dfn>pause</dfn> a given <var>audio-producing
object</var> it must run the following steps:

<ol>
  <li>
    If <var>audio-producing object</var> is an {{HTMLMediaElement}} object, then
    <a lt="pause a media element">pause media element</a>
    <var>audio-producing object</var> and terminate these steps.
  </li>
  <li>
    If <var>audio-producing object</var> is an {{AudioContext}} object, then
    <a lt="suspend a web audio object">suspend web audio object</a>
    <var>audio-producing object</var> and terminate these steps.
  </li>
</ol>

When the user agent is to <dfn>indefinitely pause</dfn> a given
<var>audio-producing object</var>, the user agent must <a>pause</a>
<var>audio-producing object</var> and, then proceed to remove it from its
<a>current media session</a>'s list of
<a>audio-producing participants</a>.

When the user agent is to <dfn>unpause</dfn> a given <var>audio-producing
object</var> it must run the following steps:

<ol>
  <li>
    If <var>audio-producing object</var> is an {{HTMLMediaElement}} object, then
    <a lt="unpause a media element">unpause media element</a>
    <var>audio-producing object</var> and terminate these steps.
  </li>
  <li>
    If <var>audio-producing object</var> is an {{AudioContext}} object, then
    <a lt="resume a web audio object">resume web audio object</a>
    <var>audio-producing object</var> and terminate these steps.
  </li>
</ol>

When an <a>audio-producing object</a> is to <dfn>duck</dfn> the user agent must
ensure its output volume is lowered.

When an <a>audio-producing object</a> is to <dfn>unduck</dfn> the user agent
should restore its output volume to the same level that was observed prior to
the original corresponding <a>duck</a> request.

<p class=note>
  When an <a>audio-producing object</a> is <a lt="duck">ducked</a> any reduction
  in volume applied by the user agent is not intended to be observable to web
  pages.
</p>

<h3 id="activating-a-media-session">Activating a media session</h3>

To <dfn>activate</dfn> a <var>media session</var>, run these steps:

<ol>
  <li>
    If <var>media session</var> is already <code><a lt="active media session
    state">active</a></code>, then return success.
  </li>
  <li>
    Optionally, based on platform conventions, request the most appropriate
    platform-level media focus for <var>media session</var> based on its
    <a>kind</a>.

    If this step is run and platform-level media focus can not be obtained for
    any reason, then return failure.
  </li>
  <li>
    Run these substeps:

    <dl class=switch>
      <dt>
        If <var>media session</var>'s <a>kind</a> is
        "<code><a>content</a></code>"
      </dt>
      <dd>
        <ol>
          <li>
            Optionally, based on platform conventions, the user agent may show
            an ongoing media interface in the underlying platform's
            notifications area and/or show an ongoing media interface in the
            underlying platform's lock screen area, using any available <a
            lt="media session metadata">metadata</a>.
          </li>
        </ol>
      </dd>
      <dt>
        If <var>media session</var>'s <a>kind</a> is
        "<code><a>transient</a></code>" or "<code><a>transient-solo</a></code>"
      </dt>
      <dd class="note">
        The user agent should not provide user access to any hardware or
        software media keys and not display any ongoing media interface in the
        underlying platform's notifications area or show any ongoing media
        interface in the underlying platform's lock screen area for
        "<code><a>transient</a></code>" or
        "<code><a>transient-solo</a></code>"-based
        <a>media sessions</a>.
      </dd>
      <dt>
        If <var>media session</var>'s <a>kind</a> is
        "<code><a>ambient</a></code>"
      </dt>
      <dd>
        If <var>media session</var>'s <a>top-level browsing context</a> is not
        at least partially visible on at least one screen, then return failure.

        <p class="note">
          The user agent should not provide user access to any hardware or
          software media keys and not display any ongoing media interface in the
          underlying platform's notifications area or show any ongoing media
          interface in the underlying platform's lock screen area for
          "<code><a>ambient</a></code>"-based <a>media sessions</a>.
        </p>
      </dd>
    </dl>
  </li>
  <li>
    Set <var>media session</var>'s <a>resume list</a> to an empty list.
  </li>
  <li>
    Set <var>media session</var>'s <a>state</a> to
    <code><a lt="active media session state">active</a></code>, then return
    success.
  </li>
</ol>

<h3 id="interrupting-a-media-session">Interrupting a media session</h3>

An <code><a lt="active media session state">active</a></code> <a>media
session</a> may be interrupted at any time. This typically occurs when another
application or another <a>media session</a> requests and is granted a level of
platform media focus that affects the <a>media session</a> based on its
<a>kind</a>.

Interruptions can be both transient or permanent. A transient interruption means
we can either choose to <a>duck</a> our media content and continue playing it
out at a reduced volume for the duration of the interruption; or <a>pause</a>
our media content for the duration of the interruption and, then, resume
playback when that interruption ends. A permanent interruption means we must <a
lt="indefinitely pause">pause our media content indefinitely</a>.

When a start-of-interruption notification event is received from the platform,
then the user agent must run the
<a>media session interruption algorithm</a> against all known <a>media
sessions</a>, passing in each <a>media session</a> as <var>media session</var>.

The <dfn>media session interruption algorithm</dfn> takes one argument,
<var>media session</var>, and consists of the following steps.

<ol>
  <li>
    If <var>media session</var>'s <a>state</a> is not
    <code><a lt="active media session state">active</a></code>, then terminate
    these steps.
  </li>
  <li>
    Let <var>interrupting kind</var> be the <a>kind</a> that triggered this
    interruption.

    <!-- TODO(philipj): The interruption may not come from another media session
    at all. https://github.com/whatwg/mediasession/issues/100 -->
  </li>
  <li>
    Run these substeps:

    <dl class=switch>
      <dt>
        If <var>interrupting kind</var> is "<code><a>content</a></code>"
      </dt>
      <dd>
        <ol>
          <li>
            If <var>media session</var>'s <a>kind</a> is
            "<code><a>content</a></code>" then
            <a>indefinitely pause</a> all of <var>media session</var>'s
            <a>audio-producing participants</a> and set <var>media
            session</var>'s <a>state</a> to <code><a lt="idle media session
            state">idle</a></code>.

            <p class="note">
              This implies that the next time the <var>media session</var> is
              <a>activated</a>, that we will re-request media focus according to
              the steps defined in that algorithm.
            </p>
          </li>
          <li>
            Optionally, based on platform conventions, the user agent must
            remove any previously established ongoing media interface in the
            underlying platform's notifications area and any ongoing media
            interface in the underlying platform's lock screen area for
            <var>media session</var>, if any.
          </li>
          <li>
            Optionally, based on platform conventions, the user agent must
            prevent any hardware and/or software media keys from controlling
            playback of
            <var>media session</var>'s <a>audio-producing participants</a>.
          </li>
        </ol>
      </dd>
      <dt>
        If <var>interrupting kind</var> is "<code><a>transient</a></code>"
      </dt>
      <dd>
        <ol>
          <li>
            If <var>media session</var>'s <a>kind</a> is not
            "<code><a>content</a></code>", then terminate these steps.
          </li>

          <li>
            For each <var>audio-producing object</var> in <var>media
            session</var>'s list of <a>audio-producing participants</a>:

            <ol>
              <li>
                If <var>audio-producing object</var> is not currently playing,
                or is not otherwise running, then terminate these substeps and
                continue at the next available <var>audio-producing
                object</var>.
              </li>
              <li>
                <a>Duck</a> <var>audio-producing object</var>.
              </li>
              <li>
                Add <var>audio-producing object</var> to <var>media
                session</var>'s <a>resume list</a>.
              </li>
            </ol>
          </li>
          <li>
            Set <var>media session</var>'s <a>state</a> to <code><a
            lt="interrupted media session state">interrupted</a></code>.

            <p class="note">
              This implies that the next time the <a>media session continuation
              algorithm</a> is run for <var>media session</var> that we will
              re-activate this <a>media session</a> according to the steps
              defined in that algorithm.
            </p>
          </li>
        </ol>
      </dd>
      <dt>
        If <var>interrupting kind</var> is "<code><a>transient-solo</a></code>"
      </dt>
      <dd>
        <ol>
          <li>
            If <var>media session</var>'s <a>kind</a> is not
            "<code><a>content</a></code>", "<code><a>transient</a></code>" or
            "<code><a>transient-solo</a></code>", then terminate these steps.
          </li>

          <li>
            For each <var>audio-producing object</var> in <var>media
            session</var>'s list of <a>audio-producing participants</a>:

            <ol>
              <li>
                If <var>audio-producing object</var> is not currently playing,
                or is not otherwise running, then terminate these substeps and
                continue at the next available <var>audio-producing
                object</var>.
              </li>
              <li>
                <a>Pause</a> <var>audio-producing object</var>.
              </li>
              <li>
                Add <var>audio-producing object</var> to <var>media
                session</var>'s <a>resume list</a>.
              </li>
            </ol>
          </li>
          <li>
            Set <var>media session</var>'s <a>state</a> to <code><a
            lt="interrupted media session state">interrupted</a></code>.

            <p class="note">
              This implies that the next time the <a>media session continuation
              algorithm</a> is run for <var>media session</var> that we will
              re-activate this <a>media session</a> according to the steps
              defined in that algorithm.
            </p>
          </li>
        </ol>
      </dd>
    </dl>
  </li>
</ol>

<p>&nbsp;</p>

When an end-of-interruption notification event is received from the platform,
then the user agent must run the <a>media session continuation algorithm</a>
against all known <a>media sessions</a>, passing in each <a>media session</a> as
<var>media session</var>.

The <dfn>media session continuation algorithm</dfn> takes one argument,
<var>media session</var>, and consists of the following steps.

<ol>
  <li>
    If <var>media session</var>'s <a>state</a> is not
    <code><a lt="interrupted media session state">interrupted</a></code>, then
    terminate these steps.
  </li>
  <li>
    Let <var>interrupting kind</var> be the <a>kind</a> that initially triggered
    this interruption.

    <!-- TODO(philipj): The interruption may not come from another media session
    at all. https://github.com/whatwg/mediasession/issues/100 -->
  </li>
  <li>
    Run these substeps:

    <dl class=switch>
      <dt>
        If <var>interrupting kind</var> is "<code><a>transient</a></code>"
      </dt>
      <dd>
        <ol>
          <li>
            If <var>media session</var>'s <a>kind</a> is not
            "<code><a>content</a></code>", then terminate these steps.
          </li>
          <li>
            <a>Unduck</a> each <var>audio-producing object</var> in <var>media
            session</var>'s <a>resume list</a>.
          </li>
          <li>
            Set <var>media session</var>'s <a>resume list</a> to an empty list.
          </li>
          <li>
            Set <var>media session</var>'s <a>state</a> to <code><a lt="active
            media session state">active</a></code>.
          </li>
        </ol>
      </dd>
      <dt>
        If <var>interrupting kind</var> is "<code><a>transient-solo</a></code>"
      </dt>
      <dd>
        <ol>
          <li>
            If <var>media session</var>'s <a>kind</a> is not
            "<code><a>content</a></code>", "<code><a>transient</a></code>", or
            "<code><a>transient-solo</a></code>", then terminate these steps.
          </li>
          <li>
            <a>Unpause</a> each <var>audio-producing object</var> in <var>media
            session</var>'s <a>resume list</a>.
          </li>
          <li>
            Set <var>media session</var>'s <a>resume list</a> to an empty list.
          </li>
          <li>
            Set <var>media session</var>'s <a>state</a> to <code><a lt="active
            media session state">active</a></code>.
          </li>
        </ol>
      </dd>
    </dl>
  </li>
</ol>

<br>

After a {{visibilitychange}} event has been fired at a <a>top-level browsing
context</a>, known as <var>the browsing context</var>, the user agent must run
the following steps:

<ol>
  <li>
    If {{visibilityState}} is not "{{hidden}}" or "{{visible}}", then terminate
    these steps.
  </li>
  <li>
    For each <a>media session</a> in <var>the browsing context</var> with a
    <a>kind</a> of "<code><a>ambient</a></code>" run the following substeps:

    <ol>
      <li>
        Let <var>s</var> be the current <a>media session</a>.
      </li>
      <li>
        If {{visibilityState}} is "{{hidden}}" and <var>s</var>'s <a>state</a>
        is <code><a lt="active media session state">active</a></code>, then run
        the following substeps:

        <ol>
          <li>
            For each <var>audio-producing object</var> in <var>s</var>'s list of
            <a>audio-producing participants</a>, run the following substeps:

            <ol>
              <li>
                If <var>audio-producing object</var> is not currently playing,
                or is not otherwise running, then terminate these substeps and
                continue at the next available <var>audio-producing
                object</var>.
              </li>
              <li>
                <a>Pause</a> <var>audio-producing object</var>.
              </li>
              <li>
                Add <var>audio-producing object</var> to <var>media
                session</var>'s <a>resume list</a>.
              </li>
            </ol>
          </li>
          <li>
            Set <var>s</var>'s
            <a>state</a> to <code><a lt="interrupted media session
            state">interrupted</a></code>.
          </li>
          <li>
            Terminate these substeps and continue at the next available
            <a>media session</a>.
          </li>
        </ol>
      </li>

      <li>
        If {{visibilityState}} is "{{visible}}" and <var>s</var>'s <a>state</a>
        is <code><a lt="interrupted media session state">interrupted</a></code>,
        then run the following substeps:

        <ol>
          <li>
            <a>Unpause</a> each <var>audio-producing object</var> in
            <var>s</var>'s <a>resume list</a>.
          </li>
          <li>
            Set <var>s</var>'s <a>resume list</a> to an empty list.
          </li>
          <li>
            Set <var>s</var>'s <a>state</a> to <code><a lt="active media session
            state">active</a></code>.
          </li>
          <li>
            Terminate these substeps and continue at the next available
            <a>media session</a>.
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h3 id="deactivating-a-media-session">Deactivating a media session</h3>

To <dfn>deactivate</dfn> a <var>media session</var>, run these steps:

<ol>
  <li>
    <a>Indefinitely pause</a> all of <var>media session</var>'s
    <a>audio-producing participants</a>.
  </li>
  <li>
    Set <var>media session</var>'s <a>resume list</a> to an empty list.
  </li>
  <li>
    Set <var>media session</var>'s <a>audio-producing participants</a>
    to an empty list.
  </li>
  <li>
    Run the <a>media session deactivation algorithm</a> for <var>media
    session</var>.
  </li>
</ol>

The <dfn>media session deactivation algorithm</dfn> takes one argument,
<var>media session</var>, and consists of the following steps.

<ol>
  <li>
    If <var>media session</var>'s <a>state</a> is
    <code><a lt="idle media session state">idle</a></code>, then terminate these
    steps.
  </li>
  <li>
    If <var>media session</var> still has one or more <a>audio-producing
    participants</a>, then terminate these steps.
  </li>
  <li>
    Optionally, based on platform conventions, the user agent must release any
    currently held platform media focus for <var>media session</var>.
  </li>
  <li>
    Optionally, based on platform conventions, the user agent must remove any
    previously established ongoing media interface in the underlying platform's
    notifications area and any ongoing media interface in the underlying
    platform's lock screen area for <var>media session</var>, if any.
  </li>
  <li>
    Optionally, based on platform conventions, the user agent must prevent any
    hardware and/or software media keys from controlling playback of
    <var>media session</var>'s <a>audio-producing participants</a>.

    <p class="note">
      If the algorithm reaches this step then <var>media session</var> can not
      have any remaining <a>audio-producing participants</a>.
    </p>
  </li>
  <li>
    Set <var>media session</var>'s <a>state</a> to
    <code><a lt="idle media session state">idle</a></code>.

    <p class="note">
      This implies that the next time the <var>media session</var> is
      <a>activated</a>, that we will re-request media focus according to the
      steps defined in that algorithm.
    </p>
  </li>
</ol>

<h2 id="the-mediametadata-interface">The {{MediaMetadata}} interface</h2>

<pre class="idl">

[Constructor(MediaMetadataInit init)]
interface MediaMetadata {
  readonly attribute DOMString title;
  readonly attribute DOMString artist;
  readonly attribute DOMString album;
};

dictionary MediaMetadataInit {
  DOMString title = "";
  DOMString artist = "";
  DOMString album = "";
};
</pre>

The <dfn constructor
for="MediaMetadata"><code>MediaMetadata(<var>init</var>)</code></dfn>
constructor, when invoked, must run the following steps:

<ol>
  <li>
    Let <var>metadata</var> be a new {{MediaMetadata}} object.
  </li>
  <li>
    Set <var>metadata</var>'s {{MediaMetadata/title}}, {{MediaMetadata/artist}},
    and {{MediaMetadata/album}} attributes to the values of <var>init</var>'s
    {{MediaMetadataInit/title}}, {{MediaMetadataInit/artist}}, and
    {{MediaMetadataInit/album}} members, respectively.
  </li>
  <li>
    Return <var>metadata</var>.
  </li>
</ol>

<h2 id="extensions-to-the-htmlmediaelement-interface">Extensions to the
{{HTMLMediaElement}} interface</h2>

<pre class="idl">
partial interface HTMLMediaElement {
  attribute MediaSession? session;
};
</pre>

<dl class=domintro>
  <dt>
    <code><var>media</var> . {{HTMLMediaElement/session}}</code> [ = <code>
    session</code> ]
  </dt>
  <dd>
    Returns the <a>current media session</a> for the <a>media element</a>, if
    any, or null otherwise.

    Can be set, to change the <a>current media session</a>.

    Throws an {{InvalidStateError}} exception if the <a>media element</a>'s
    {{networkState}} is {{NETWORK_LOADING}} or {{NETWORK_IDLE}}.
  </dd>
</dl>

The <dfn attribute for="HTMLMediaElement"
lt="session"><code>session</code></dfn> attribute on a <a>media element</a>, on
getting, must return the element's <a>current media session</a>, if any, or null
otherwise. On setting, the user agent must run the following steps:

<ol>
  <li>
    If the <a>media element</a>'s {{networkState}} is {{NETWORK_LOADING}} or
    {{NETWORK_IDLE}}, throw an {{InvalidStateError}} exception and abort these
    steps.
  </li>
  <li>
    Set the <a>media elements</a>'s <a>current media session</a> to the new
    value.
  </li>
</ol>

<h3 id="activating-a-media-session-from-an-htmlmediaelement-object">Activating a
media session from an {{HTMLMediaElement}} object</h3>

<!-- XXX https://www.w3.org/Bugs/Public/show_bug.cgi?id=28625 -->

When the {{play()}} method on a <a>media element</a> is invoked from script –
or a <a>media element</a> is otherwise played from the web page (e.g. via its
{{controls}}) – and that <a>media element</a>'s {{paused}} attribute is true
and its {{HTMLMediaElement/readyState}} attribute has the value
{{HAVE_FUTURE_DATA}} or {{HAVE_ENOUGH_DATA}} then the user agent must run the
following steps, passing in <a>media element</a> as <var>media element</var>:

<ol>
  <li>
    Let <var>media session</var> be the value of <var>media element</var>'s
    <a>current media session</a>.
  </li>
  <li>
    If <var>media element</var> is not currently in <var>media session</var>'s
    list of <a>audio-producing participants</a>, then append <var>media
    element</var> to this list.
  </li>
  <li>
    <a>Activate</a> <var>media session</var>.
  </li>
  <li>
    If <a>activate</a> failed, <a>pause</a> <var>media element</var>.
  </li>
  <!-- TODO(philipj): Integrate with HTML to better precisely when implicit
  activation happens and clarify that it's only the paused attribute that's
  temporarily paused, there should be no actual playback, however short. -->
</ol>


<h3
id="interrupting-a-media-session-from-an-htmlmediaelement-object">Interrupting a
media session from an {{HTMLMediaElement}} object</h3>

When the user agent is to <dfn>pause a media element</dfn> for a given
<var>media element</var> it must run that <a>media element</a>'s <a>internal
pause steps</a>.

<!-- XXX https://www.w3.org/Bugs/Public/show_bug.cgi?id=28625 -->

When the user agent is to <dfn>unpause a media element</dfn> for a given
<var>media element</var> it must invoke that <a>media element</a>'s {{play()}}
method.

<h3
id="deactivating-a-media-session-from-an-htmlmediaelement-object">Deactivating a
media session from an {{HTMLMediaElement}} object</h3>

When a <a>media element</a>'s <a lt="ended playback">playback has ended</a>, the
user agent must <a>release media element from its media session</a>.

Any time a <a>media element</a>'s <a lt="media element load algorithm">load
algorithm</a> is run by the user agent, it must <a>release media element from
its media session</a>.

When the user agent is to <dfn>release media element from its media
session</dfn> for a given <var>media element</var> it must run the following
steps:

<ol>
  <li>
    Let <var>media session</var> be the value of <var>media element</var>'s
    <a>current media session</a>.
  </li>
  <li>
    If <var>media element</var> is not currently in <var>media session</var>'s
    list of <a>audio-producing participants</a>, then terminate these steps.
  </li>
  <li>
    If <var>media element</var> is in <var>media session</var>'s <a>resume
    list</a> then remove it from this list.
  </li>
  <li>
    Remove <var>media element</var> from <var>media session</var>'s list of
    <a>audio-producing participants</a>.
  </li>
  <li>
    Run the <a>media session deactivation algorithm</a> for <var>media
    session</var>.
  </li>
</ol>

<h2 id="extensions-to-the-audiocontext-interface">Extensions to the
{{AudioContext}} interface</h2>

<pre class="idl">
partial interface AudioContext {
  attribute MediaSession? session;
};
</pre>

<dl class=domintro>
  <dt>
    <code><var>context</var> . {{AudioContext/session}}</code> [ = <code>
    session</code> ]
  </dt>
  <dd>
    Returns the <a>current media session</a> for the {{AudioContext}} object, if
    any, or null otherwise.

    Can be set, to change the <a>current media session</a>.

    Throws an {{InvalidStateError}} exception if the {{AudioContext}} object's
    {{state}} attribute is "{{running}}".
  </dd>
</dl>

The <dfn attribute for="AudioContext" lt="session"><code>session</code></dfn>
attribute on an {{AudioContext}} object, on getting, must return the object's
<a>current media session</a>, if any, or null otherwise. On setting, the user
agent must run the following steps:

<ol>
  <li>
    If the {{AudioContext}} object's {{state}} attribute is "{{running}}", throw
    an {{InvalidStateError}} exception and abort these steps.
  </li>
  <li>
    Set the {{AudioContext}} object's <a>current media session</a> to the new
    value.
  </li>
</ol>

<h3 id="interrupting-a-media-session-from-an-audiocontext-object">Interrupting a
media session from an {{AudioContext}} object</h3>

When the user agent is to <dfn>suspend a web audio object</dfn> for a given
{{AudioContext}} object it must invoke that {{AudioContext}} object's
{{suspend()}} method.

When the user agent is to <dfn>resume a web audio object</dfn> for a given
{{AudioContext}} object it must invoke that {{AudioContext}} object's
{{resume()}} method.

<h2 id="examples">Examples</h2>

<em>This section is non-normative.</em>

<div class="example">
  For music or podcasts, using a <a>media session</a> of <a>kind</a>
  "<code><a>content</a></code>" can be appropriate.

  <pre class="lang-javascript">
    var audio = document.createElement("audio");
    audio.src = "podcast.mp3";
    audio.session = new MediaSession(); // "content" is the default kind
    audio.play();
  </pre>

  If metadata is available, providing it will allow for a richer user interface:

  <pre class="lang-javascript">
    audio.session.metadata = new MediaMetadata({
      title: "Episode Title",
      artist: "Podcast Host",
      album: "Podcast Title",
    });
  </pre>
</div>

<div class="example">
  For playlists or chapters of an audio book, multiple <a>media elements</a> can
  share a single <a>media session</a>.

  <pre class="lang-javascript">
    var audio1 = document.createElement("audio");
    audio1.src = "chapter1.mp3";

    var audio2 = document.createElement("audio");
    audio2.src = "chapter2.mp3";

    var sharedSession = new MediaSession();
    audio1.session = audio2.session = sharedSession;

    audio1.play();
    audio1.addEventListener("ended", function() {
      audio2.play();
    });
  </pre>

  Because the session is shared, the metadata must be updated to reflect what is
  currently playing.

  <pre class="lang-javascript">
    function updateMetadata(event) {
      sharedSession.metadata = new MediaMetadata({
        title: event.target == audio1 ? "Chapter 1" : "Chapter 2",
        artist: "An Author",
        album: "A Book",
      });
    }

    audio1.addEventListener("play", updateMetadata);
    audio2.addEventListener("play", updateMetadata);
  </pre>
</div>

<div class="example">
  For games, using a <a>media session</a> of <a>kind</a>
  "<code><a>ambient</a></code>" can be appropriate. Because {{AudioContext}}
  objects are created in the "{{running}}" state, it's necessary to suspend
  before setting the session.

  <pre class="lang-javascript">
    var context = new AudioContext();
    context.suspend().then(function() {
      context.session = new MediaSession("ambient");
      context.resume();
    });
  </pre>
</div>

<h2 id="acknowledgments" class="no-num">Acknowledgments</h2>

The editor would like to thank Paul Adenot, Jake Archibald, Tab Atkins, Jonathan
Bailey, Marcos Caceres, Domenic Denicola, Ralph Giles, Anne van Kesteren, Tobie
Langel, Michael Mahemoff, Jer Noble, Elliott Sprehn, Chris Wilson, and Jörn
Zaefferer for their participation in technical discussions that ultimately made
this specification possible.

Special thanks go to Philip Jägenstedt and David Vest for their help in
designing every aspect of media sessions and for their seemingly infinite
patience in working through the initial design issues; Jer Noble for his help in
building a model that also works well within the iOS audio focus model; and
Mounir Lamouri and Anton Vayvod for their early involvement, feedback and
support in making this specification happen.

This standard is written by Rich Tibbett (<a
href="http://www.opera.com">Opera</a>, <a
href="mailto:richt@opera.com">richt@opera.com</a>).

Per <a rel="license"
href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, to the extent
possible under law, the editors have waived all copyright and related or
neighboring rights to this work.

<script id=head src=https://resources.whatwg.org/dfn.js></script>
